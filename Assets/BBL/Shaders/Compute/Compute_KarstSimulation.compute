#pragma kernel FillVolume
#pragma kernel FractureVolume
#pragma kernel MargolusSwap
#pragma kernel InjectWater
#pragma kernel CalculateFlux
#pragma kernel ResolveFlux

#include "Assets/BBL/Shaders/ShaderIncludes/Karst/Simulation/KarstCore.hlsl"
#include "Assets/BBL/Shaders/ShaderIncludes/Karst/Simulation/KarstVolumeInitialization.hlsl"
#include "Assets/BBL/Shaders/ShaderIncludes/Karst/Simulation/ParticlePhysics.hlsl"
#include "Assets/BBL/Shaders/ShaderIncludes/Karst/Simulation/FluidPhysics.hlsl"

RWTexture3D<float4> _FillTarget;

[numthreads(8,8,8)]
void FillVolume (uint3 id : SV_DispatchThreadID) // 0
{
    if (ThreadOutOfBounds(id)) 
        return;
    
    KarstMaterial material = GetMaterial(id);
    if (material.density > 0)
    {
        float matPacked = PackMaterialIndex(material.materialIndex);
        _FillTarget[id] = float4(matPacked, material.density, material.waterAmount, 1);
    }
    else
    {
        _FillTarget[id] = float4(0, 0, 0, 0);
    }
}

RWTexture3D<float4> _FractureTarget;

[numthreads(8,8,8)]
void FractureVolume (uint3 id : SV_DispatchThreadID) // 1
{
    if (ThreadOutOfBounds(id)) 
        return;

    float4 targetSample = _FractureTarget[id];
    float currentDensity = targetSample.g;

    if (currentDensity < 1e-4)
        return;
    
    float fractureDensity = GetFractureDensity(id);
    float newDensity = targetSample.g * fractureDensity * 0.05;
    float waterAmount = (1 - newDensity) * 0.5f;
    _FractureTarget[id] = float4(targetSample.r,
        newDensity,
        waterAmount,
        targetSample.a);
}

RWTexture3D<float4> _MargolusTarget;

[numthreads(8,8,8)]
void MargolusSwap (uint3 id : SV_DispatchThreadID) // 2
{
    uint3 baseId;
    if (!GetMargolusBaseId(id, baseId))
        return;

    MargolusRow topRow; MargolusRow bottomRow;
    GetMargolusRows(baseId, _MargolusTarget, topRow, bottomRow);

    ApplyVerticalGravity(topRow, bottomRow);
    ApplyHorizontalSlopes(topRow, bottomRow);
    ApplyDiagonalSlopes(topRow, bottomRow);

    ResolveMargolusRows(baseId, _MargolusTarget, topRow, bottomRow);
}

RWTexture3D<float4> _InjectTarget;

[numthreads(8,8,8)]
void InjectWater (uint3 id : SV_DispatchThreadID) // 3
{
    if (ThreadOutOfBounds(id))
        return;

    float height = GetUvw(id).y;

    if (!IsOnStoneLayer(height, _FloorAmount, _StoneAmount))
        return;

    KarstMaterial voxel = SampleVoxel(id, _InjectTarget);

    if (!CanInjectWater(voxel))
        return;

    InjectWater(_InjectTarget, voxel, id, _DeltaTime);
}

RWTexture3D<float4> _FluxSource;

[numthreads(8,8,8)]
void CalculateFlux(uint3 id : SV_DispatchThreadID) // 4
{
    if (ThreadOutOfBounds(id))
        return;

    KarstMaterial voxel = SampleVoxel(id, _FluxSource);

    if (!HasWater(voxel))
        return;

    UpdateFlux(_FluxSource, id, _DeltaTime);
}

[numthreads(8,8,8)]
void ResolveFlux(uint3 id : SV_DispatchThreadID) // 5
{
    if (ThreadOutOfBounds(id))
        return;

    KarstMaterial voxel = SampleVoxel(id, _FluxSource);
    
    if (!IsPermeable(voxel.density))
        return;

    float outflow = GetTotalOutflow(id);
    float inflow = GetTotalInflow(id);
    float flow = inflow - outflow;
    
    voxel.waterAmount += flow;
    voxel.waterAmount = max(voxel.waterAmount, 0.0f);
    _FluxSource[id] = ResolveMaterial(voxel);
}